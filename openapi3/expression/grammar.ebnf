@@grammar::RuntimeExpression
@@whitespace :: //
@@comments :: //
@@eol_comments :: //
@@keyword :: if elsif "shared-network" group host subnet pool class subclass
@@parseinfo :: True

start::RuntimeExpression = expression $ ;

# expression = ( "$url" / "$method" / "$statusCode" / "$request." source / "$response." source )
expression::Expression
    = root:"$url"
    | root:"$method"
    | root:"$statusCode"
    | root:"$request." next:source
    | root:"$response." next:source
    ;

# source = ( header-reference / query-reference / path-reference / body-reference )
source
    = header_reference
    | query_reference
    | path_reference
    | body_reference
    ;

# header-reference = "header." token
header_reference::Header = "header." key:token ;

# query-reference = "query." name
query_reference::Query = "query." key:name ;

# path-reference = "path." name
path_reference::Path = "path." key:name ;

# body-reference = "body" ["#" json-pointer ]
body_reference::Body = "body" fragment:[ json_pointer ] ;

# json-pointer    = *( "/" reference-token )
json_pointer::JSONPointer = "#/" tokens:"/".{ reference_token }*;

# reference-token = *( unescaped / escaped )
reference_token = { unescaped | escaped }* ;

# unescaped       = %x00-2E / %x30-7D / %x7F-10FFFF
# ; %x2F ('/') and %x7E ('~') are excluded from 'unescaped'
unescaped = /[^\/~]/ ;


# escaped         = "~" ( "0" / "1" )
#; representing '~' and '/', respectively
escaped = "~" ( "0" | "1" ) ;

# name = *( CHAR )
name = /[\w]*/ ;

# token = 1*tchar
# token = {tchar}+;
token = /[!#$%&'*+-\.^-`|~\w]+/ ;

#tchar = "!" / "#" / "$" / "%" / "&" / "'" / "*" / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~" / DIGIT / ALPHA"
# tchar = /[^\(\),\/:;<=>?@[\]{}]/ ;
#tchar = /!#$%&'*+-\.^-`|~\w/ ;
